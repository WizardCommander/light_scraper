"""Lodes 2025 Price List data.

This module loads product codes, prices, and specifications from the
Lodes 2025 Price List JSON file (output/price_list_data.json).

The JSON file is generated by scripts/parse_lodes_price_list.py from the PDF.
"""

import json
from pathlib import Path
from typing import TypedDict

from loguru import logger


class ProductVariant(TypedDict):
    """Price list variant data."""

    sku: str  # Full SKU with color code (e.g., "14126 1000")
    color_code: str  # Color code only (e.g., "1000")
    color_name_en: str  # English color name (e.g., "Matte White")
    color_name_de: str  # German color name (e.g., "Weiß Matt")
    price_eur: float  # Price in EUR (VAT excluded)


class ProductDimensions(TypedDict, total=False):
    """Product dimensions in centimeters."""

    length: float  # Length in cm
    width: float  # Width in cm
    height: float  # Height in cm


class ProductInfo(TypedDict):
    """Price list product information."""

    base_sku: str  # Base SKU without color code (e.g., "14126")
    product_name: str  # Full product name (e.g., "Kelly small dome 50")
    url_slug: str  # URL slug for the product (e.g., "kelly")
    variants: list[ProductVariant]  # List of color variants
    cable_length: str  # Cable/rope length (e.g., "max 250cm")
    light_source: str  # Light source specification
    dimmability: str  # Dimmability type (e.g., "TRIAC")
    voltage: str  # Voltage specification
    ip_rating: str  # IP rating (e.g., "IP20")
    dimensions: (
        ProductDimensions | None
    )  # Product dimensions (length, width, height in cm)


# Color code mapping
COLOR_CODES = {
    "1000": {
        "en": "Matte White",
        "de": "Weiß Matt",
        "it": "Bianco Opaco",
        "code_suffix": "9010",
    },
    "2000": {
        "en": "Matte Black",
        "de": "Schwarz Matt",
        "it": "Nero Opaco",
        "code_suffix": "9005",
    },
    "3500": {"en": "Coppery Bronze", "de": "Bronze", "it": "Bronzo Ramato"},
    "4500": {"en": "Matte Champagne", "de": "Champagner Matt", "it": "Champagne Opaco"},
}

def _load_json_price_list() -> dict[str, ProductInfo]:
    """Load price list from JSON file.

    Returns:
        Dictionary mapping base_sku -> ProductInfo

    Raises:
        FileNotFoundError: If the JSON price list file is not found
    """
    json_path = Path("data/price_list_data.json")

    if not json_path.exists():
        raise FileNotFoundError(
            f"Price list JSON not found at {json_path}. "
            f"Ensure the data folder contains the price list JSON file."
        )

    try:
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        products = {}
        for base_sku, product_data in data.get("products", {}).items():
            # Convert JSON format to ProductInfo format
            variants = []
            for variant in product_data.get("variants", []):
                color_code = variant.get("color_code", "")

                # Look up color name from COLOR_CODES, use generic name as fallback
                color_info = COLOR_CODES.get(color_code, {})
                color_name_en = color_info.get("en", f"Color {color_code}")
                color_name_de = color_info.get("de", f"Farbe {color_code}")

                # Skip variants with null or 0 price (likely parsing errors)
                price = variant.get("price_eur") or 0.0

                variants.append({
                    "sku": variant.get("sku", ""),
                    "color_code": color_code,
                    "color_name_en": color_name_en,
                    "color_name_de": color_name_de,
                    "price_eur": price,
                })

            # Only add products that have at least one variant with valid data
            if variants:
                products[base_sku] = {
                    "base_sku": base_sku,
                    "product_name": product_data.get("product_name", ""),
                    "url_slug": product_data.get("url_slug", ""),
                    "variants": variants,
                    "cable_length": "",  # Not extracted from PDF
                    "light_source": "",  # Not extracted from PDF
                    "dimmability": "",   # Not extracted from PDF
                    "voltage": "",       # Not extracted from PDF
                    "ip_rating": "",     # Not extracted from PDF
                    "dimensions": None,  # Not extracted from PDF
                }

        logger.info(f"Loaded {len(products)} products from {json_path}")
        return products

    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in price list file: {e}")


# Load all products from JSON
ALL_PRODUCTS = _load_json_price_list()

logger.info(f"Price list initialized with {len(ALL_PRODUCTS)} products")


def get_product_by_slug(slug: str) -> list[ProductInfo]:
    """Get all products matching a URL slug.

    Args:
        slug: URL slug (e.g., "kelly", "a-tube-small")

    Returns:
        List of matching ProductInfo dictionaries
    """
    matches = []
    slug = slug.lower()
    for p in ALL_PRODUCTS.values():
        p_slug = p["url_slug"].lower()
        # Direct match or one is a sub-slug of the other (for family matching)
        if p_slug == slug or (slug in p_slug) or (p_slug in slug):
            matches.append(p)
    return matches


def get_product_by_base_sku(base_sku: str) -> ProductInfo | None:
    """Get product by base SKU.

    Args:
        base_sku: Base SKU (e.g., "14126", "09622")

    Returns:
        ProductInfo dictionary or None if not found
    """
    return ALL_PRODUCTS.get(base_sku)


def get_slug_by_base_sku(base_sku: str) -> str | None:
    """Get URL slug for a base SKU (reverse lookup).

    Args:
        base_sku: Base SKU (e.g., "14126")

    Returns:
        URL slug (e.g., "kelly") or None if not found

    Examples:
        >>> get_slug_by_base_sku("14126")
        "kelly"
        >>> get_slug_by_base_sku("99999")
        None
    """
    product = get_product_by_base_sku(base_sku)
    return product["url_slug"] if product else None


def get_variant_price(sku: str) -> float | None:
    """Get price for a variant SKU.

    Args:
        sku: Full variant SKU (e.g., "14126 1000")

    Returns:
        Price in EUR or None if not found
    """
    # Extract base SKU (first part before space)
    base_sku = sku.split()[0] if " " in sku else sku

    product = ALL_PRODUCTS.get(base_sku)
    if not product:
        return None

    # Find matching variant
    for variant in product["variants"]:
        if variant["sku"] == sku:
            return variant["price_eur"]

    return None


def get_all_product_colors(product_info: ProductInfo) -> str:
    """Get comma-separated list of all color names in German.

    Args:
        product_info: Product information dictionary

    Returns:
        Comma-separated color names (e.g., "Weiß Matt, Schwarz Matt, Bronze, Champagner Matt")
    """
    colors = [v["color_name_de"] for v in product_info["variants"]]
    return ", ".join(colors)
